{"name":"ConcurrentReader","tagline":"IDataReader made Thread-Safe","body":"## Objective\r\nImprove performance of data reading by using concurrency. Making a IDataReader wrapper Thread-Safe.\r\n\r\n## Solution\r\nThe call to the IDataReader Read() Method starts a loaderThread that loads all records into a List.\r\n![Flow](https://raw.github.com/AlienEngineer/ConcurrentReader/master/Doc/b8b4b6f3.png)\r\n\r\nFrom this point on the Read() Method is used to allocate data from the List to the Current Thread. When the current thread tries to read that it will actually get data from a Tuple type.\r\n\r\nThis solution enables the reading process to be as quick as possible making sure the database is released as soon as the data is loaded. Not having to wait for the data computation.\r\n\r\n***\r\n\r\n## Extensions\r\nThe reader can be used in concurrency with other threads any way you wish. Still there are a few extension methods to ease some pain.\r\n\r\n```C#\r\n// Returns some IDataReader implementation...\r\nIDataReader reader = GetReader();\r\n// Wraps the IDataReader making it Thread-Safe\r\nIConcurrentDataReader cReader = reader.AsParallel(); \r\n\r\nint records = 0;\r\n\r\n// The ForEach creates Tasks to execute asynchronously the work\r\ncReader.ForEach(r =>\r\n{\r\n    // Independent operation \r\n    Compute(r);\r\n    // Dependent operation therefore the \r\n    // Interlocked.Increment to be synchronized.\r\n    Interlocked.Increment(ref records);\r\n});\r\n\r\n// or...\r\nreader.ParallelForEach(r =>\r\n{\r\n    // Independent operation \r\n    Compute(r);\r\n    // Dependent operation therefore the \r\n    // Interlocked.Increment to be synchronized.\r\n    Interlocked.Increment(ref records);\r\n});\r\n\r\n```\r\n\r\n***\r\n\r\n\r\n## The good stuff\r\nTo make thing a bit more easy it is possible to get a full line as a ITuple type.\r\n```C#\r\ncReader.ForEach(r => \r\n{\r\n    ITuple tuple = r.GetData();\r\n    Console.WriteLine(\"E-mail dated with {0} was sent...\", \r\n                      tuple.GetValue<DateTime>());\r\n    SendEMail(tuple);\r\n});\r\n```\r\nStill the regular use has the advantage of the reading lock getting released as soon as the data is loaded and not when all the computations are done.\r\n```C#\r\ntry\r\n{\r\n    while(cReader.Read())\r\n    {\r\n        Compute(r);\r\n    }\r\n}\r\nfinally \r\n{\r\n    reader.Close();\r\n}\r\n```\r\nSometimes we need to stop the reading process when a given condition occurs so when can achieve this like so.\r\n```C#\r\n// The reader will stop reading records from the \r\n// IDataReader when the predicate is true.\r\nGetReader().AsParallel(r => r.GetInt32(0) < 10).ForEach(r =>\r\n{\r\n    Compute(r);\r\n});\r\n```\r\n\r\n***\r\n\r\n\r\n## Keep the reader order\r\nIt is often required that the reading order is maintained. The IConcurrentDataReader has two extension methods to do this.\r\n\r\nThe first method a foreach with a transform Func type (Func<ITuple, TModel>) this function is called for every record in parallel and the return is an IEnumerable<TModel>.\r\n\r\n```C#\r\n// Mapping / transform operation\r\nvar orders = GetReader().ParallelTransform<Order>(t =>\r\n{\r\n    return new Order\r\n    {\r\n        OrderId = t.GetValue<int>(\"orderId\")\r\n    };\r\n});\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}